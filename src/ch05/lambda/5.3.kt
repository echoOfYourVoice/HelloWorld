package ch05.lambda

import java.io.File

fun main() {
    val people = listOf(Person("Alice", 29), Person("Bob", 31))
    println(people.map(Person::name).filter { it.startsWith("A") })
    /*
    Справочник по стандартной библиотеке Kotlin говорит, что fi l ter и map
    возвращают список. Это значит, что данная цепочка вызовов создаст два
    списка: один - для хранения результатов функции fi lter и другой - для
    результатов функции map. Это не проблема, если в исходном списке всего
    пара элементов, но в случае со списком из миллиона элементов это может
    существенно снизить эффективность операции.
    Для повышения эффективности нужно реализовать операцию с применением последовательностей вместо коллекций:
     */
    people.asSequence()
        .map(Person::name).filter { it.startsWith("A") }
        .toList()
    /*
    Точка входа для выполнения отложенных операций в Kotlin - интерфейс
    Sequence. Он представляет собой простую последовательность элементов,
    которые могут перечисляться один за другим. Интерфейс Sequence определяет только один метод - iterator, который используется для получения значений последовательности.
     */
    /*
    Операции над последовательностями делятся на две категории: промежуточные и завершающие. Промежуточная операция возвращает другую
    последовательность, которая знает, как преобразовать элементы исходной последовательности. Завершающая операция возвращает результат,
    который может быть коллекцией, элементом, числом или любым другим
    объектом, полученным в ходе преобразований исходной коллекции
     */
    listOf(1, 2, 3, 4).asSequence()
        .map { print("map($it) "); it * it }
        .filter { print("filter($it) "); it % 2 == 0 }
    /*
    Этот код ничего не выведет в консоль. Это значит, что преобразования
    map и filter отложены и будут применены, только когда потребуется вернуть результат (т. е. во время выполнения завершающей операции)
     */

    println(listOf(1, 2, 3, 4).asSequence()
        .map { it * it }.find { it > 3 })

    // СОЗДАНИЕ ПОСЛЕДОВАТЕЛЬНОСТЕЙ
    val naturalNumbers = generateSequence(0) {it + 1}
    val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }
    println(numbersTo100.sum())
    /*
    Обратите внимание, что naturalNumbers и numbersTo100 в данном примере - последовательности с отложенным выполнением операций.
    Реальные числа в этих последовательностях не будут вычислены до вызова завершающей операции (в данном случае sum).
     */
    val file = File("Users/svtk/.HiddenDir/a.txt")
    println(file.isInsideHiddenDirectory())
    /*
    Еще раз напомним, что вы создаете последовательность, предоставляя
    первый элемент и способ получения каждого последующего элемента. Заменив any на find, вы получите желаемый каталог. Обратите внимание, что
    последовательности позволяют остановить обход родителей, как только
    нужный каталог будет найден.
     */


}

fun File.isInsideHiddenDirectory() =
    generateSequence(this) { it.parentFile }.any { it.isHidden }