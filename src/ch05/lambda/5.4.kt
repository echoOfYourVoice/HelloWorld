package ch05.lambda

// Использование функциональных интерфейсов JAVA

fun main() {
    /*
val button = Button()
    button.setOnClickListener{ view -> ...}
     */
    /*
    Это возможно потому, что интерфейс OnCl ickListener имеет только
    один абстрактный метод. Такие интерфейсы называются функциональными интерфейсами, или SАМ-интерфейсами (Single Abstract Method - с
    единственным абстрактным методом). В J ava API полным-полно функциональных интерфейсов (таких как Runnable и Cal lable), и методов для работы с ними. Kotlin позволяет использовать лямбда-выражения в вызовах
    методов Java, принимающих в качестве параметров функциональные интерфейсы, что гарантирует чистоту и идиоматичность кода на Kotlin
     */

    /*
    /* Java */
    void postponeComputation( int delay , RunnaЫe computation);
    В Kotlin можно вызвать этот метод, передав в аргументе лямбда-выражение. Компилятор автоматически преобразует его в экземпляр
    Runnable:
    postponeComputation( 1000) { println(42) }
     */
    /*
    SАМ-конструктор - это функция, сгенерированная компилятором, которая позволяет явно выполнить преобразование лямбда-выражения в
    экземпляр функционального интерфейса. Его можно использовать в контекстах, где компилятор не применяет преобразования автоматически. Например, если есть метод, который возвращает экземпляр функционального интерфейса, вы не сможете вернуть лямбда-выражение напрямую: его
    нужно завернуть в вызов SАМ-конструктора. Вот простая демонстрация
     */
createAllDoneRunnable().run()
    /*
    Имя SАМ-конструктора совпадает с именем соответствующего функционального интерфейса. SАМ-конструктор принимает один аргумент -
    лямбда-выражение, которое будет использовано как тело единственного
    абстрактного метода в функциональном интерфейсе, - и возвращает экземпляр класса, реализующего данный интерфейс.
    Помимо создания возвращаемых значений, SАМ-конструкторы используются, чтобы сохранить в переменной экземпляр функционального
    интерфейса, созданный из лямбда-выражения. Предположим, вы хотите
    использовать один обработчик событий для нескольких кнопок, как в следующем листинге (в Аndrоid-приложении этот код может быть частью метода Activity . onCreate).
     */
    /*
    val listener = OnClickListener {view ->
        val text = when(view.id) {
            R.id.button1 -> "First button"
            R.id.button2 -> "Second button"
            else -> "Unknown button"
        }
        toast(text)
    }
    Экземпляр в переменной listener проверяет, какая кнопка породила событие, и ведет себя соответственно. Можно определить обработчик событий, используя объявление объекта, реализующего интерфейс
    OnClickListener, но SАМ-конструктор - более лаконичный вариант.
     */
    println(getPattern())
}

fun createAllDoneRunnable(): Runnable {
    return Runnable { println("All done") }
}

val month = "(JAN|FEB|MAR|APR|MAY|JUN|JUL|AUG|SEP|OCT|NOV|DEC)"

fun getPattern(): String = """\d{2}\s$month\s\d{4}"""

